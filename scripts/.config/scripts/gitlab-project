#!/usr/bin/env bash
# gitlab-project - open GitLab pipelines or merge requests page for current repo
# Usage: gitlab-project [remote] [--host HOST_OVERRIDE] [--mr|--merge-requests]
set -euo pipefail

remote="origin"
host_override=""
open_mr=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --host)
      shift
      if [[ $# -eq 0 ]]; then
        echo "Error: --host requires an argument" >&2
        exit 2
      fi
      host_override="$1"
      ;;
    --host=*)
      host_override="${1#--host=}"
      ;;
    --mr|--merge-requests)
      open_mr=1
      ;;
    -h|--help)
      cat <<'EOF'
Usage: gitlab-project [remote] [--host HOST_OVERRIDE] [--mr|--merge-requests]

Examples:
  gitlab-project               # open pipelines for origin
  gitlab-project --mr          # open merge requests for origin
  gitlab-project --host gitlab.example.com/gitlab # override host/base path
EOF
      exit 0
      ;;
    -*)
      echo "Unknown option: $1" >&2
      exit 2
      ;;
  esac
  shift
done

if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  echo "Not inside a git repository." >&2
  exit 1
fi

if ! remote_url=$(git remote get-url "$remote" 2>/dev/null); then
  echo "Remote '$remote' not found." >&2
  exit 1
fi

# strip trailing .git
remote_url_nogit="${remote_url%.git}"

host=""
path=""

if [[ "$remote_url_nogit" =~ ^git@([^:]+):(.+)$ ]]; then
  host="${BASH_REMATCH[1]}"
  path="${BASH_REMATCH[2]}"
elif [[ "$remote_url_nogit" =~ ^ssh://([^/]+)/(.*)$ ]]; then
  host="${BASH_REMATCH[1]}"
  path="${BASH_REMATCH[2]}"
elif [[ "$remote_url_nogit" =~ ^https?://([^/]+)/(.*)$ ]]; then
  host="${BASH_REMATCH[1]}"
  path="${BASH_REMATCH[2]}"
else
  echo "Unable to parse remote URL: $remote_url" >&2
  exit 1
fi

if [[ -n "$host_override" ]]; then
  host="$host_override"
fi

# percent-encode a string (encode reserved chars except '/')
# encode each path segment but preserve '/' separators.
url_encode_segment() {
  local s="$1"
  local i len c hex out
  len=${#s}
  out=""
  for (( i=0; i<len; i++ )); do
    c=${s:i:1}
    case "$c" in
      [a-zA-Z0-9.~_-]) out+="$c" ;;
      *)
        printf -v hex '%%%02X' "'$c"
        out+="$hex"
        ;;
    esac
  done
  printf '%s' "$out"
}

IFS='/' read -r -a segs <<< "$path"
encoded_path=""
for idx in "${!segs[@]}"; do
  seg="${segs[idx]}"
  enc="$(url_encode_segment "$seg")"
  if [[ $idx -gt 0 ]]; then
    encoded_path+="/"
  fi
  encoded_path+="$enc"
done

# decide endpoint
if [[ $open_mr -eq 1 ]]; then
  endpoint="merge_requests"
else
  endpoint="pipelines"
fi

url="https://${host}/${encoded_path}/-/$(printf '%s' "$endpoint")"

echo "${endpoint^} URL: $url"

# attempt to open in a browser (supports Linux, macOS, WSL2)
open_url() {
  local u="$1"
  if command -v xdg-open >/dev/null 2>&1; then
    xdg-open "$u" >/dev/null 2>&1 &
    return 0
  fi
  if command -v open >/dev/null 2>&1; then
    open "$u" >/dev/null 2>&1 &
    return 0
  fi
  # WSL / WSL2 support:
  if command -v wslview >/dev/null 2>&1; then
    wslview "$u" >/dev/null 2>&1 &
    return 0
  fi
  if command -v explorer.exe >/dev/null 2>&1; then
    explorer.exe "$(printf '%s' "$u")" >/dev/null 2>&1 &
    return 0
  fi
  return 1
}

if ! open_url "$url"; then
  echo "No opener found (tried xdg-open, open, wslview, explorer.exe)."
  echo "Copy the URL above to your browser."
fi
